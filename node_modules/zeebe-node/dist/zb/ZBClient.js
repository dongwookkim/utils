"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = __importDefault(require("chalk"));
const events_1 = require("events");
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const promise_retry_1 = __importDefault(require("promise-retry"));
const uuid_1 = require("uuid");
const lib_1 = require("../lib");
const ConfigurationHydrator_1 = require("../lib/ConfigurationHydrator");
const GRPCClient_1 = require("../lib/GRPCClient");
const OAuthProvider_1 = require("../lib/OAuthProvider");
// tslint:disable-next-line: no-duplicate-imports
const utils_1 = require("../lib/utils");
const ZBLogger_1 = require("../lib/ZBLogger");
const ZBWorker_1 = require("./ZBWorker");
const idColors = [
    chalk_1.default.yellow,
    chalk_1.default.green,
    chalk_1.default.cyan,
    chalk_1.default.magenta,
    chalk_1.default.blue,
];
class ZBClient extends events_1.EventEmitter {
    constructor(gatewayAddress, options) {
        super();
        this.connectionTolerance = ZBClient.DEFAULT_CONNECTION_TOLERANCE;
        this.connected = false;
        this.closing = false;
        this.workerCount = 0;
        this.workers = [];
        if (typeof gatewayAddress === 'object') {
            options = gatewayAddress;
            gatewayAddress = undefined;
        }
        const opts = options ? options : {};
        this.options = {
            longPoll: ZBClient.DEFAULT_LONGPOLL_PERIOD,
            ...opts,
            retry: opts.retry !== false,
        };
        this.options.loglevel =
            process.env.ZB_NODE_LOG_LEVEL ||
                process.env.ZEEBE_NODE_LOG_LEVEL ||
                this.options.loglevel ||
                'INFO';
        this.loglevel = this.options.loglevel;
        this.stdout = this.options.stdout || console;
        this.logger = new ZBLogger_1.ZBLogger({
            loglevel: this.loglevel,
            namespace: this.options.logNamespace || 'ZBClient',
            pollInterval: this.options.longPoll,
            stdout: this.stdout,
        });
        this.options = ConfigurationHydrator_1.ConfigurationHydrator.configure(gatewayAddress, this.options);
        this.gatewayAddress = `${this.options.hostname}:${this.options.port}`;
        this.oAuth = this.options.oAuth
            ? new OAuthProvider_1.OAuthProvider(this.options.oAuth)
            : undefined;
        this.useTLS =
            this.options.useTLS === true ||
                (!!this.options.oAuth && this.options.useTLS !== false);
        this.basicAuth = this.options.basicAuth;
        this.connectionTolerance =
            this.options.connectionTolerance || this.connectionTolerance;
        this.onConnectionError = this.options.onConnectionError;
        this.onReady = this.options.onReady;
        this.gRPCClient = this.constructGrpcClient({
            namespace: this.options.logNamespace || 'ZBClient',
            onConnectionError: () => this._onConnectionError(),
            onReady: () => this._onReady(),
        });
        this.retry = this.options.retry !== false;
        this.maxRetries =
            this.options.maxRetries || ZBClient.DEFAULT_MAX_RETRIES;
        this.maxRetryTimeout =
            this.options.maxRetryTimeout || ZBClient.DEFAULT_MAX_RETRY_TIMEOUT;
        // Send command to broker to eagerly fail / prove connection.
        // This is useful for, for example: the Node-Red client, which wants to
        // display the connection status.
        this.topology().catch(e => {
            // Swallow exception to avoid throwing if retries are off
            if (e.thisWillNeverHappenYo) {
                this.emit('never');
            }
        });
    }
    async cancelWorkflowInstance(workflowInstanceKey) {
        utils_1.Utils.validateNumber(workflowInstanceKey, 'workflowInstanceKey');
        return this.executeOperation('cancelWorkflowInstance', () => this.gRPCClient.cancelWorkflowInstanceSync({
            workflowInstanceKey,
        }));
    }
    /**
     *
     * @param id - A unique identifier for this worker.
     * @param taskType - The BPMN Zeebe task type that this worker services.
     * @param taskHandler - A handler for activated jobs.
     * @param options - Configuration options for the worker.
     */
    createWorker(id, taskType, taskHandler, options = {}, onConnectionError) {
        if (this.closing) {
            throw new Error('Client is closing. No worker creation allowed!');
        }
        const idColor = idColors[this.workerCount++ % idColors.length];
        onConnectionError = onConnectionError || options.onConnectionError;
        const onReady = options.onReady;
        // tslint:disable-next-line: variable-name
        const _onConnectionError = (err) => {
            worker.emit('connectionError', err);
            // Allow a per-worker handler for specialised behaviour
            if (onConnectionError) {
                onConnectionError(err);
            }
        };
        // tslint:disable-next-line: variable-name
        const _onReady = () => {
            worker.emit('ready');
            if (onReady) {
                onReady();
            }
        };
        // Merge parent client options with worker override
        options = {
            ...this.options,
            loglevel: this.loglevel,
            onReady: undefined,
            ...options,
        };
        // Give worker its own gRPC connection
        const workerGRPCClient = this.constructGrpcClient({
            namespace: 'ZBWorker',
            onConnectionError: _onConnectionError,
            onReady: _onReady,
            tasktype: taskType,
        });
        const worker = new ZBWorker_1.ZBWorker({
            gRPCClient: workerGRPCClient,
            id,
            idColor,
            onConnectionError,
            options: { ...this.options, ...options },
            taskHandler,
            taskType,
            zbClient: this,
        });
        this.workers.push(worker);
        return worker;
    }
    /**
     * Gracefully shut down all workers, draining existing tasks, and return when it is safe to exit.
     * @returns Promise
     * @memberof ZBClient
     */
    async close(timeout) {
        this.closePromise =
            this.closePromise ||
                new Promise(async (resolve) => {
                    // Prevent the creation of more workers
                    this.closing = true;
                    await Promise.all(this.workers.map(w => w.close(timeout)));
                    await this.gRPCClient.close(timeout); // close the client GRPC channel
                    resolve();
                });
        return this.closePromise;
    }
    completeJob(completeJobRequest) {
        const withStringifiedVariables = lib_1.stringifyVariables(completeJobRequest);
        this.logger.debug(withStringifiedVariables);
        return this.gRPCClient.completeJobSync(withStringifiedVariables);
    }
    createWorkflowInstance(configOrbpmnProcessId, variables) {
        const isConfigObject = (conf) => typeof conf === 'object';
        const version = isConfigObject(configOrbpmnProcessId)
            ? configOrbpmnProcessId.version || -1
            : -1;
        const bpmnProcessId = isConfigObject(configOrbpmnProcessId)
            ? configOrbpmnProcessId.bpmnProcessId
            : configOrbpmnProcessId;
        const variablesConcrete = isConfigObject(configOrbpmnProcessId)
            ? configOrbpmnProcessId.variables
            : variables;
        const createWorkflowInstanceRequest = {
            bpmnProcessId,
            variables: variablesConcrete,
            version,
        };
        return this.retry === true
            ? this.executeOperation('createWorkflowInstance', () => this.gRPCClient.createWorkflowInstanceSync(lib_1.stringifyVariables(createWorkflowInstanceRequest)))
            : this.gRPCClient.createWorkflowInstanceSync(lib_1.stringifyVariables(createWorkflowInstanceRequest));
    }
    createWorkflowInstanceWithResult(configOrBpmnProcessId, variables) {
        const isConfigObject = (config) => typeof config === 'object';
        const bpmnProcessIdConcrete = isConfigObject(configOrBpmnProcessId)
            ? configOrBpmnProcessId.bpmnProcessId
            : configOrBpmnProcessId;
        const variablesConcrete = isConfigObject(configOrBpmnProcessId)
            ? configOrBpmnProcessId.variables
            : variables;
        const versionConcrete = isConfigObject(configOrBpmnProcessId)
            ? configOrBpmnProcessId.version || -1
            : -1;
        const requestTimeoutConcrete = isConfigObject(configOrBpmnProcessId)
            ? configOrBpmnProcessId.requestTimeout || 0
            : 0;
        const fetchVariables = isConfigObject(configOrBpmnProcessId)
            ? configOrBpmnProcessId.fetchVariables
            : undefined;
        const createWorkflowInstanceRequest = lib_1.stringifyVariables({
            bpmnProcessId: bpmnProcessIdConcrete,
            variables: variablesConcrete,
            version: versionConcrete,
        });
        return this.retry === true
            ? this.executeOperation('createWorkflowInstanceWithResult', () => this.gRPCClient.createWorkflowInstanceWithResultSync({
                fetchVariables,
                request: createWorkflowInstanceRequest,
                requestTimeout: requestTimeoutConcrete,
            })).then(res => lib_1.parseVariables(res))
            : this.gRPCClient
                .createWorkflowInstanceWithResultSync({
                fetchVariables,
                request: createWorkflowInstanceRequest,
                requestTimeout: requestTimeoutConcrete,
            })
                .then(res => lib_1.parseVariables(res));
    }
    /**
     *
     * @param workflow - A path or array of paths to .bpmn files or an object describing the workflow
     * @param {redeploy?: boolean} - Redeploy workflow. Defaults to true.
     * If set false, will not redeploy a workflow that exists.
     */
    async deployWorkflow(workflow) {
        const workflows = Array.isArray(workflow) ? workflow : [workflow];
        const readFile = (filename) => {
            if (fs.existsSync(filename)) {
                return fs.readFileSync(filename);
            }
            const name = `${filename}.bpmn`;
            if (fs.existsSync(name)) {
                return fs.readFileSync(name);
            }
            throw new Error(`${filename} not found.`);
        };
        const workFlowRequests = workflows.map(wf => {
            if (typeof wf === 'object') {
                return {
                    definition: wf.definition,
                    name: wf.name,
                    type: 1,
                };
            }
            else {
                return {
                    definition: readFile(wf),
                    name: path.basename(wf),
                    type: 1,
                };
            }
        });
        if (workFlowRequests.length > 0) {
            return this.executeOperation('deployWorkflow', () => this.gRPCClient.deployWorkflowSync({
                workflows: workFlowRequests,
            }));
        }
        else {
            return {
                key: '-1',
                workflows: [],
            };
        }
    }
    failJob(failJobRequest) {
        return this.executeOperation('failJob', () => this.gRPCClient.failJobSync(failJobRequest));
    }
    /**
     * Return an array of task-types specified in a BPMN file.
     * @param file - Path to bpmn file.
     */
    getServiceTypesFromBpmn(files) {
        if (typeof files === 'string') {
            files = [files];
        }
        return lib_1.BpmnParser.getTaskTypes(lib_1.BpmnParser.parseBpmn(files));
    }
    /**
     * Publish a message to the broker for correlation with a workflow instance.
     * @param publishMessageRequest - The message to publish.
     */
    publishMessage(publishMessageRequest) {
        return this.executeOperation('publishMessage', () => this.gRPCClient.publishMessageSync(lib_1.stringifyVariables(publishMessageRequest)));
    }
    /**
     * Publish a message to the broker for correlation with a workflow message start event.
     * @param publishStartMessageRequest - The message to publish.
     */
    publishStartMessage(publishStartMessageRequest) {
        /**
         * The hash of the correlationKey is used to determine the partition where this workflow will start.
         * So we assign a random uuid to balance workflow instances created via start message across partitions.
         *
         * We make the correlationKey optional, because the caller can specify a correlationKey + messageId
         * to guarantee an idempotent message.
         *
         * Multiple messages with the same correlationKey + messageId combination will only start a workflow once.
         * See: https://github.com/zeebe-io/zeebe/issues/1012 and https://github.com/zeebe-io/zeebe/issues/1022
         */
        const publishMessageRequest = {
            correlationKey: uuid_1.v4(),
            ...publishStartMessageRequest,
        };
        return this.executeOperation('publishStartMessage', () => this.gRPCClient.publishMessageSync(lib_1.stringifyVariables(publishMessageRequest)));
    }
    resolveIncident(incidentKey) {
        return this.executeOperation('resolveIncident', () => this.gRPCClient.resolveIncidentSync(incidentKey));
    }
    setVariables(request) {
        /*
        We allow developers to interact with variables as a native JS object, but the Zeebe server needs it as a JSON document
        So we stringify it here.
        */
        if (typeof request.variables === 'object') {
            request.variables = JSON.stringify(request.variables);
        }
        return this.executeOperation('setVariables', () => this.gRPCClient.setVariablesSync(request));
    }
    /**
     *
     * Report a business error (i.e. non-technical) that occurs while processing a job.
     * The error is handled in the workflow by an error catch event.
     * If there is no error catch event with the specified errorCode then an incident will be raised instead.
     */
    throwError(throwErrorRequest) {
        return this.executeOperation('throwError', () => this.gRPCClient.throwErrorSync(throwErrorRequest));
    }
    /**
     * Return the broker cluster topology
     */
    topology() {
        return this.executeOperation('topology', this.gRPCClient.topologySync);
    }
    updateJobRetries(updateJobRetriesRequest) {
        return this.executeOperation('updateJobRetries', () => this.gRPCClient.updateJobRetriesSync(updateJobRetriesRequest));
    }
    constructGrpcClient({ onReady, onConnectionError, tasktype, namespace, }) {
        return new GRPCClient_1.GRPCClient({
            basicAuth: this.basicAuth,
            connectionTolerance: this.connectionTolerance,
            host: this.gatewayAddress,
            loglevel: this.loglevel,
            namespace,
            oAuth: this.oAuth,
            onConnectionError,
            onReady,
            options: { longPoll: this.options.longPoll },
            packageName: 'gateway_protocol',
            protoPath: path.join(__dirname, '../../proto/zeebe.proto'),
            service: 'Gateway',
            stdout: this.stdout,
            tasktype,
            useTLS: this.useTLS,
        });
    }
    /**
     * If this.retry is set true, the operation will be wrapped in an configurable retry on exceptions
     * of gRPC error code 14 - Transient Network Failure.
     * See: https://github.com/grpc/grpc/blob/master/doc/statuscodes.md
     * If this.retry is false, it will be executed with no retry, and the application should handle the exception.
     * @param operation A gRPC command operation
     */
    async executeOperation(operationName, operation, retries) {
        return this.retry
            ? this.retryOnFailure(operationName, operation, retries)
            : operation();
    }
    _onConnectionError() {
        this.connected = false;
        if (this.lastConnectionError) {
            const now = new Date();
            const delta = now.valueOf() - this.lastConnectionError.valueOf();
            if (delta > this.connectionTolerance / 2) {
                if (this.onConnectionError) {
                    // @TODO is this the right window?
                    this.onConnectionError();
                }
                this.emit('connectionError');
            }
        }
        else {
            if (this.onConnectionError) {
                this.onConnectionError();
            }
            this.emit('connectionError');
        }
        this.lastConnectionError = new Date();
    }
    _onReady() {
        this.connected = true;
        if (this.lastReady) {
            const now = new Date();
            const delta = now.valueOf() - this.lastReady.valueOf();
            if (delta > this.connectionTolerance / 2) {
                // @TODO is this the right window?
                if (this.onReady) {
                    this.onReady();
                }
                this.emit('ready');
            }
        }
        else {
            if (this.onReady) {
                this.onReady();
            }
            this.emit('ready');
        }
        this.lastReady = new Date();
    }
    /**
     * This function takes a gRPC operation that returns a Promise as a function, and invokes it.
     * If the operation throws gRPC error 14, this function will continue to try it until it succeeds
     * or retries are exhausted.
     * @param operation A gRPC command operation that may fail if the broker is not available
     */
    async retryOnFailure(operationName, operation, retries = this.maxRetries) {
        return promise_retry_1.default((retry, n) => {
            if (this.closing || this.gRPCClient.channelClosed) {
                return Promise.resolve();
            }
            if (n > 1) {
                this.logger.error(`[${operationName}]: Attempt ${n} (max: ${this.maxRetries}).`);
            }
            return operation().catch(err => {
                // This could be DNS resolution, or the gRPC gateway is not reachable yet, or Backpressure
                const isNetworkError = err.message.indexOf('14') === 0 ||
                    err.message.indexOf('Stream removed') !== -1;
                const isBackpressure = err.message.indexOf('8') === 0 || err.code === 8;
                if (isNetworkError || isBackpressure) {
                    this.logger.error(`[${operationName}]: ${err.message}`);
                    retry(err);
                }
                // The gRPC channel will be closed if close has been called
                if (this.gRPCClient.channelClosed) {
                    return Promise.resolve();
                }
                throw err;
            });
        }, {
            maxTimeout: this.maxRetryTimeout,
            retries,
        });
    }
}
exports.ZBClient = ZBClient;
ZBClient.DEFAULT_CONNECTION_TOLERANCE = 3000;
ZBClient.DEFAULT_MAX_RETRIES = 50;
ZBClient.DEFAULT_MAX_RETRY_TIMEOUT = 5000;
ZBClient.DEFAULT_LONGPOLL_PERIOD = 30000;
//# sourceMappingURL=ZBClient.js.map