/// <reference types="node" />
import { EventEmitter } from 'events';
import * as ZB from '../lib/interfaces';
import { ZBWorker } from './ZBWorker';
export declare class ZBClient extends EventEmitter {
    static readonly DEFAULT_CONNECTION_TOLERANCE = 3000;
    private static readonly DEFAULT_MAX_RETRIES;
    private static readonly DEFAULT_MAX_RETRY_TIMEOUT;
    private static readonly DEFAULT_LONGPOLL_PERIOD;
    connectionTolerance: number;
    connected: boolean;
    gatewayAddress: string;
    loglevel: ZB.Loglevel;
    onReady?: () => void;
    onConnectionError?: () => void;
    private logger;
    private closePromise?;
    private closing;
    private gRPCClient;
    private options;
    private workerCount;
    private workers;
    private retry;
    private maxRetries;
    private maxRetryTimeout;
    private oAuth?;
    private basicAuth?;
    private useTLS;
    private stdout;
    private lastReady?;
    private lastConnectionError?;
    /**
     *
     * @param options Zero-conf constructor. The entire ZBClient connection config can be passed in via the environment.
     */
    constructor(options?: ZB.ZBClientOptions);
    constructor(gatewayAddress: string, options?: ZB.ZBClientOptions);
    cancelWorkflowInstance(workflowInstanceKey: string | number): Promise<void>;
    /**
     *
     * @param id - A unique identifier for this worker.
     * @param taskType - The BPMN Zeebe task type that this worker services.
     * @param taskHandler - A handler for activated jobs.
     * @param options - Configuration options for the worker.
     */
    createWorker<WorkerInputVariables = ZB.GenericWorkerInputVariables, CustomHeaderShape = ZB.GenericCustomHeaderShape, WorkerOutputVariables = ZB.GenericWorkerOutputVariables>(id: string | null, taskType: string, taskHandler: ZB.ZBWorkerTaskHandler<WorkerInputVariables, CustomHeaderShape, WorkerOutputVariables>, options?: ZB.ZBWorkerOptions & ZB.ZBClientOptions, onConnectionError?: ZB.ConnectionErrorHandler | undefined): ZBWorker<WorkerInputVariables, CustomHeaderShape, WorkerOutputVariables>;
    /**
     * Gracefully shut down all workers, draining existing tasks, and return when it is safe to exit.
     * @returns Promise
     * @memberof ZBClient
     */
    close(timeout?: number): Promise<any>;
    completeJob(completeJobRequest: ZB.CompleteJobRequest): Promise<void>;
    createWorkflowInstance<Variables = ZB.GenericWorkflowVariables>(bpmnProcessId: string, variables: Variables): Promise<ZB.CreateWorkflowInstanceResponse>;
    createWorkflowInstance<Variables = ZB.GenericWorkflowVariables>(config: {
        bpmnProcessId: string;
        variables: Variables;
        version: number;
    }): Promise<ZB.CreateWorkflowInstanceResponse>;
    createWorkflowInstanceWithResult<Variables = ZB.GenericWorkflowVariables, Result = ZB.GenericWorkerOutputVariables>(config: {
        bpmnProcessId: string;
        version?: number;
        variables: Variables;
        requestTimeout?: number;
        fetchVariables?: string[];
    }): Promise<ZB.CreateWorkflowInstanceWithResultResponse<Result>>;
    createWorkflowInstanceWithResult<Variables = ZB.GenericWorkflowVariables, Result = ZB.GenericWorkerOutputVariables>(bpmnProcessId: string, variables: Variables): Promise<ZB.CreateWorkflowInstanceWithResultResponse<Result>>;
    /**
     *
     * @param workflow - A path or array of paths to .bpmn files or an object describing the workflow
     * @param {redeploy?: boolean} - Redeploy workflow. Defaults to true.
     * If set false, will not redeploy a workflow that exists.
     */
    deployWorkflow(workflow: string | string[] | {
        definition: Buffer;
        name: string;
    }): Promise<ZB.DeployWorkflowResponse>;
    failJob(failJobRequest: ZB.FailJobRequest): Promise<void>;
    /**
     * Return an array of task-types specified in a BPMN file.
     * @param file - Path to bpmn file.
     */
    getServiceTypesFromBpmn(files: string | string[]): Promise<string[]>;
    /**
     * Publish a message to the broker for correlation with a workflow instance.
     * @param publishMessageRequest - The message to publish.
     */
    publishMessage<T = ZB.GenericWorkflowVariables>(publishMessageRequest: ZB.PublishMessageRequest<T>): Promise<void>;
    /**
     * Publish a message to the broker for correlation with a workflow message start event.
     * @param publishStartMessageRequest - The message to publish.
     */
    publishStartMessage<T = ZB.GenericWorkflowVariables>(publishStartMessageRequest: ZB.PublishStartMessageRequest<T>): Promise<void>;
    resolveIncident(incidentKey: string): Promise<void>;
    setVariables<Variables = ZB.GenericWorkflowVariables>(request: ZB.SetVariablesRequest<Variables>): Promise<void>;
    /**
     *
     * Report a business error (i.e. non-technical) that occurs while processing a job.
     * The error is handled in the workflow by an error catch event.
     * If there is no error catch event with the specified errorCode then an incident will be raised instead.
     */
    throwError(throwErrorRequest: ZB.ThrowErrorRequest): Promise<void>;
    /**
     * Return the broker cluster topology
     */
    topology(): Promise<ZB.TopologyResponse>;
    updateJobRetries(updateJobRetriesRequest: ZB.UpdateJobRetriesRequest): Promise<void>;
    private constructGrpcClient;
    /**
     * If this.retry is set true, the operation will be wrapped in an configurable retry on exceptions
     * of gRPC error code 14 - Transient Network Failure.
     * See: https://github.com/grpc/grpc/blob/master/doc/statuscodes.md
     * If this.retry is false, it will be executed with no retry, and the application should handle the exception.
     * @param operation A gRPC command operation
     */
    private executeOperation;
    private _onConnectionError;
    private _onReady;
    /**
     * This function takes a gRPC operation that returns a Promise as a function, and invokes it.
     * If the operation throws gRPC error 14, this function will continue to try it until it succeeds
     * or retries are exhausted.
     * @param operation A gRPC command operation that may fail if the broker is not available
     */
    private retryOnFailure;
}
